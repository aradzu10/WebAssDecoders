\documentclass{article}
\usepackage{ucs}
\usepackage{geometry}
\geometry{
	a4paper,
	top=30mm,
}
\usepackage[utf8x]{inputenc}
\usepackage{pgfplots,pgfplotstable}
\usepackage{amsmath}
\usepackage[english,hebrew]{babel}
\usepackage{setspace}
\usepackage{graphicx}
\graphicspath{{./project_pic/}}
\title{\vspace{-2.0cm}ספר הפרויקט $-$ החבאת קוד \L{JS}}
\author{\L{Arad Zulti - 315240564} \and \L{Matan Dombelski - 318439981}}
\newcommand{\goal}{\textbf{מטרה. }}
\newcommand{\action}{\textbf{ביצוע. }}
\renewcommand{\thesubsubsection}{\arabic{subsubsection}.\arabic{section}}
\begin{document} 
	\onehalfspacing
	
	\maketitle
	\tableofcontents
	
	\section{על הפרויקט}
	\subsection{רקע}
		האינטרנט הפך לכלי המעורב בהבטים רבים בחיינו. 
		בעקבות כך, דפדפני האינטרנט תפסו מקום משמעותי והיו חייבים להתשתפר בביצועיהם )שיפור במהירות, חיסכון בזיכרון, וכו'(. 
		הצורך בשיפור המהירות של הדפדפנים, הוביל ליצירת אסמבלר לדפדפן ובהתאמה את הנלווה בכך. 
		נוצרה שפת אסמבלי חדשה הנקראת 
		\L{Web Assembly}, 
		מהדר 
		\L{(Compiler)} 
		המקמפל קבצי 
		\L{C $\backslash$ C++} 
		לשפת האסמבלי הנ"ל, ואסמבלר היודע להריץ את קבצי האסמבלי.
		
	\subsection{מטרה}
		כיום, יש המון שיטות להרצת קוד זדוני על מחשב מטרה. 
		אחת השיטות הפופלריות הינה לשלוח ל"קורבן" קוד זדוני דרך האינטרנט. 
		כדי להתגונן מכך, דפדפנים רבים מוודאים שהקבצים שהם מקבלים אינם  מכילים קוד זדוני. 
		לדוגמא, בעזרת מעבר על הקוד ובדיקתו, הרצתו בתוך 
		\L{Sandbox}, 
		בדיקה בעזרת 
		\L{Machine Learning} 
		ועוד. 
		אחת השיטות לתקיפה, כדי לעקוף חלק מההגנות, הינה בעזרת שליחת מפענח
		\L{(Decoder)}. 
		שולחים לקורבן קוד, המייצר את הקוד הזדוני בזמן ריצה.  
		בכך הקוד הזדוני מוחבא, והזיהוי שלו הופך למסובך יותר. 
		
		מטרתנו בפרויקט היא יצירת מפענחים שונים המחבאים את הקוד הזדוני, 
		וקימפול שלהם לשפת 
		\L{Web Assembly}. 
		אנו מנצלים את העובדה שטכנולוגיית ה- 
		\L{Web Assembly} 
		חדשה, ולכן ההגנות הקיימות היום על קבצי 
		\L{Web Assembly} 
		הן מעטות וחלשות. 
		בפרט רצינו להתמודד עם כך שבכדי להגן, 
		חלק מהדפדפנים מריצים את הקבצים שהם מקבלים בתוך 
		\L{Sandbox}
		וכך יודעים האם הם זדוניים. 

		\section{חקירת קדם}
		\subsection{למה הקוד הזדוני כתוב ב- SJ ולא ב- ++C?}
		\textbf{מוטיבציה:} 
		היינו רוצים להצליח להריץ וירוסים קיימים. \\
		מכיוון שהדפדפן מממש סביבה וירטואלית לאסמבלר, פקודות 
		\L{System calls} 
		רבות חסומות לקוד ה- 
		\L{C++}, 
		ולכן חלק מהוירוסים לא יעבדו. 
		לעומת זאת, לוירוסים הכתובים ב- 
		\L{Javascript} 
		אין הבדל בדרך הרצתם, ולכן אין משהו נוסף המגביל אותם מלרוץ. 		
		\subsection{איך מריצים קוד הנוצר בזמן ריצה?} 
		כאשר אנו מייצרים את הקוד הזדוני, אנו בסופו של דבר מקבלים מחרוזת. 
		היינו רוצים להצליח להריץ את המחרזות המייצגת את הקוד הזדוני ב- 
		\L{Javascript}. 
		ישנן שתי דרכים לעשות זאת ב- 
		\L{Javascript}. 
		הדרך הראשונה היא בעזרת הפונקציה 
		\L{eval}. 
		היא מקבלת ביטוי, ומחשבת את מה שיש שם. בפרט יודעת לקבל מחרוזת ולחשב את מה שכתוב בתוכה. 
\begin{center}
			\L{\includegraphics{eval}}
\end{center}
		פונקציה זו עונה על דרישותינו, אך השימוש בה נתפס בעין רעה בקרב המתכנתים.\\ 
		דרך שניה שניתן להריץ דרכה מחרוזת, היא בעזרת יצירת אובייקט מסוג פונקציה. ניתן ליצור את הפונקציה ולהריץ אותה באופן הבא:  
\begin{center}
			\L{\includegraphics{new_func.png}}
\end{center}
		בדרך זו בחרנו להשתמש. 
		\section{למידת קדם}
		לימוד הטכנולוגיה הדרושה בפרויקט, הייתה חלק משמעותי ממנו. 
		\subsection{\L{C $\backslash$ C++}}
		קוד המקור של מהדר ה-
		\L{Web Assembly} 
		הוא בשפות 
		\L{C $\backslash$ C++}. 
		שפות אלה אנו מכירים ולכן לא נדרשנו ללמוד את השפות עצמן. 
		בשפות אלה כתבנו את המפענחים. 
		כמו שהוזכר קודם, נוצרת לאסמבלר סביבה וירטואלית בדפדפן ולא כל הפקודות הקיימות ב-
		\L{C $\backslash$ C++} 
		ניתנות לשימוש, כתוצאה מכך נאלצנו לוודא כי הפקודות שאנו משתמשים ממומשות. 

		\subsection{\L{Javascript}} 
		מה שמנהל את סביבת האסמבלר, וגם קוד התקיפה בפועל הינם בשפת 
		\L{Javascript}. 
		שפה שלא הכרנו כמעט, ולכן היינו צריכים ללמוד אותה. 
		חיפשנו תקיפות אמיתיות ב- 
		\L{Javascript}. 
		בנוסף נדרשנו לחקור כיצד ניתן להריץ קוד הנוצר בזמן ריצה. 
		
		\subsection{\L{Web Assembly}} 
		הטכנולוגיה העקרית בפרויקט. נדרשנו ללמוד את כל התוספות 
		\L{(Features)} 
		שמהדר ה- 
		\L{Web Assembly} 
		מוסיף לקוד ה- 
		\L{C $\backslash$ C++}. 
		דרכים לתקשר עם ה- 
		\L{Javascript}, 
		העברת מופעים 
		\L{(Instances)} 
		של מחלקות שיצרנו בקוד ה- 
		\L{C++}, 
		שימוש בקבצי מחשב בקוד ה- 
		\L{C++}, 
		ספריות חדשות )כמו תמיכה בגרפיקה של הדפדפן( ועוד. 
	\L{\begin{figure}[h]
		\centering
		\R{\caption{דוגמא לקוד \L{Javascript} בתוך קוד \L{C++}}}
		\includegraphics[scale=0.8]{Javascript_code}
	\end{figure}}
		\section{שלבי הפרויקט}
			נתאר את השלבים שעברנו בפרויקט עצמו לאחר לימוד הטכנולוגיה. 
			כל שלב שנתאר הוא מפענח בפני עצמו, המייצר קוד בזמן ריצה ומריץ אותו. 
			כל שלב המרחיב שלבים קודמים נמצאים תחת אותה הכותרת. 
			רוב השלבים דרשו מאיתנו הליך חשיבתי ארוך. נדרשנו למצוא דרכי פעולה יצרתיות כדי להגיע לתוצרים רצויים. 
			כחלק מתהליך החשיבה התייעצנו עם אנשים, וחקרנו באינטרנט.
			בכל שלב נסביר את המוטבציה שהנחתה אותנו בעשייתנו.
			
			\subsection*{תקציר כל השלבים}
			\begin{enumerate}
				\item 
				\L{Proof of concept}. 
				כתיבה של הקוד הזדוני כמחרוזת, והרצתה. 
				\item 
				כתיבה של הקוד הזדוני מוצפן בעזרת צופן 
				\L{AES}, 
				פיענוחו בזמן ריצה והרצתו. 
				נעזרנו ב- 
				\L{DLL} 
				חיצוני. 
				שלב שלא התאפשר בסוף. 
				\item 
				הצפנה של הקוד הזדוני בעזרת צופן החלפה שאנו ממשנו. 
				\item 
				הצפנה של הקוד הזדוני בעזרת צופן 
				\L{AES} 
				שאנו ממשנו. 
				\item 
				שמירה של הקוד הזדוני בקובץ נפרד. 
				\item 
				שמירה של טבלת תווים, ושמירה של מערך מספרים המייצג את בניית הקוד ע"י הטבלה. 
				\item 
				דומה לשלב הקודם, כאשר שומרים את הטבלה בצורה דינאמית. 
				\item 
				שמירה של מחרוזות משותפות, כדי לא לשמור רק תווים. 
				ובניית הטבלה בעזרתן.  
				\item 
				יצירת הקוד הזדוני ע"י ספריית אינטרנט. 
				\item 
				החבאה של הקוד הזדוני בתוך תמונה. 
				\item 
				החבאה של הקוד הזדוני בעזרת מחלקות וירושות. 
				\item 
				שילוב בין שלבי ההצפנה, שלבי ה 
				\L{Lookup Table} 
				והחבאת הקוד הזדוני בתמונה. 
				\item 
				שילוב יצירת הקוד בעזרת ספריית אינטרנט, והחבאת הקוד הזדוני במחלקות. 
				\item 
				תלית הרצת הקוד הזדוני בקלט המשתמש. 
				\item 
				כמו השלב הקודם, עם הגברת הקושי בזיהוי הקוד.  
				\item 
				ניצול על השלבים עד כה. שילוב של התלות בקלט המשתמש, החבאת הקוד בתוך המחלקות, ויצירת הקוד ע"י ספריית אינטרנט. 
			\end{enumerate}
			\subsection*{\L{Proof of Concept}}
			\subsubsection{שלב ראשון}
				\goal 
				רצינו לוודא שאנו מצליחים להריץ קוד 
				\L{Javascript} 
				שנשלח מהמפענח שלנו הכתוב ב- 
				\L{C++}. 
				כלומר, רצינו להראות ייתכנות בסיסית לפרויקט. \\				
				\action 
				כתבנו בתור $string$ את הקוד הזדוני שרצינו להריץ, וניסינו להריץ אותו דרך 
				\L{Javascript}. 
				ואכן זה הצליח. 
		\L{\begin{figure}[h]
				\centering
				\R{\caption{קוד ה \L{C++} של השלב}}
				\includegraphics[scale=0.8]{phase1}
		\end{figure}}
			\subsection*{\L{Code Encryption}}
			\subsubsection{שלב שני}
				\goal 
				כאשר כותבים $string$ בקוד הוא נשמר בתחילת הקובץ. 
				הנחנו שלא נוכל ל"החביא" את הקוד בצורה כזו,  
				לכן רצינו להצפין את הקוד בדרכים שונות, ולשמור את הקוד המוצפן והמפתח שלו כ- $strings$. 
				בזמן ריצה נפענח את הקוד הזדוני ונריץ אותו. 	\\
				\action
				השתמשנו בהצפנת 
				\L{AES}. 
				בתכנון מקדים לקחנו את הקוד הזדוני והצפנו אותו בעזרת מפתח אקראי. 
				שמרנו את המפתח והקוד כמחרוזות בקוד של המפענח שלנו, ובזמן ריצה פיענחנו את הקוד הזדוני. 
				מכיוון שהצפנת 
				\L{AES} 
				היא יחסית מסובכת נאלצנו להשתמש בספרייה חיצונית 
				המבצעת זאת. \\ 
				לאחר שסיימנו את שלב זה, ראינו שהוא לא ניתן לביצוע. 
				לא ניתן להריץ 
				\L{DLL} 
				חיצוניים ב 
				\L{Web Assembly}. 
			\subsubsection{שלב שלישי}
				\goal
				כיוון שהשלב הקודם לא עבד לנו, רצינו לממש הצפנה בעצמנו. \\
				\action
				בחרנו לממש  
				\L{Substitution Cipher} 
				)צופן החלפה(. הצפנה זו לא בטוחה אבל קל לממש אותה, ובעיני המתבונן לא פשוט להבין מה ההודעה המוצפנה. 
				כמו קודם, בתכנון מקדים הצפנו את הקוד הזדוני בעזרת מפתח אקראי. 
				שמרנו את המפתח והקוד בתור מחרוזות, ובעזרתן פיענחנו בזמן ריצה את הקוד והרצנו אותו. 
			\subsubsection{שלב רביעי}
				\goal
				החסרון כאמור בשלב הקודם, הוא שההצפנה איננה בטוחה.  
				לכן רצינו לחזור להצפנת 
				\L{AES}. \\
				\action
				לכן מימשנו בעצמו את הצפנת 
				\L{AES}. 
				השלב דומה לשלב הקודם, כאשר ההבדל הוא בסכמת ההצפנה שהתמשנו. 
			
			\subsection*{\L{Built by Lookup Tables}}
			\subsubsection{שלב חמישי}
			\goal 
			רצינו למצוא דרכים נוספות לשמירת הקוד הזדוני, חוץ מכתיבתו כמחרוזת. \\
			\action 
			רשמנו את הקוד בקובץ טקסט נפרד, ושלחנו אותו ביחד עם שאר קבצי הקוד. 
			בזמן ריצה קוראים את הקובץ ומריצים את הקוד הזדוני ששם. 
			הבעיה עם הרעיון היא שהקורבן יכול לראות את קובץ הטקסט )כי הוא מקבל גם אותו(, ולכן השלב דומה כמו לשמירת הקוד הזדוני בתור מחרוזת. 
			\subsubsection{שלב שישי} 
			\goal 
			השלבים עד עתה לא מייצרים קוד בזמן ריצה, והמחרוזות הינן סטטיות. 
			רצינו לבצע יצירה של קוד בצורה יותר דינאמית, ובכך נגביל את יכולת ניתוח קובץ הקוד. לקחנו השראה מ- 
			\L{Lookup Tables}. \\
			\action
			יצרנו מערך של תווים 
			\L{(Chars)} 
			של כל האותיות הרלוונטיות 
			)לדוגמא, התו $a$ במקום ה- $30$, התו $b$ במקום $15$, התו $;$ במקום $16$(. 
			כעת, שמרנו מערך של מספרים המרכיב את הקוד שלנו. 
			בזמן ריצה עברנו על מערך המספרים ובנינו את המחרוזת המייצגת את הקוד הזדוני. \\
			
			\noindent
			בכל זאת, חשבנו על שלוש חולשות מרכזיות. 
			נרשום בכל שלב, מה הייתה החולשה, ואיך טיפלנו בה. 
			\subsubsection{שלב שביעי}
			\goal 		
			חסרון ראשון. אנו שומרים מערך סטטי של מספרים, וכמו מחרוזת גם הוא נשמר בזכרון בתחילת הקובץ. \\
			\action
			שינינו לכך שאנו יוצרים מערך דינאמי, ומאתחלים את התאים )איזה תו לרשום מתי( בזמן ריצה. 
			בצורה כזאת, המערך לא מופיע ברצף בתחילת הקובץ אלה במקומות שונים. 
			\subsubsection{שלב שמיני}
			\goal
			חסרון שני, אנו שומרים טבלה של כל התווים הרלוונטים. 
			דבר העלול להראות קצת חשוד. \\
			\action 
			חיפשנו מילים שמורות שכיחות, שהגיוני שיופיעו בקוד. )לדוגמא 
			$success, try\ again, zero$ 
			ועוד(. 
			בצורה כזאת, כתבנו את הקוד בזמן ריצה. 
			לדוגמא, התו הראשון בקוד הוא התו הראשון של המחרוזת השלישית. 
			בעצם מה שעשינו, זה בניית הקוד ע"י שימוש בטקסט שאנו כתבנו. 
			\subsubsection{שלב תשיעי}
			\goal 
			רצינו לפתח את רעיון ה- 
			\L{Lookup Tables} 
			כך שנוכל לבנות את הקוד ע"י טקסט. \\
			\action
			שמנו לב, שניתן בזמן ריצה להוריד סיפריות 
			\L{web} 
			עם גרסא ספציפית. בחרנו בספרייה נפוצה ב- 
			\L{Javascript}, 
			ווידאנו שהיא מכילה את כל התווים שאנו צריכים. 
			בתכנון מקדים ביקשנו את הספרייה ובנינו את הקוד הזדוני בעזרתה. 
			שמרנו טבלה דו מימדית $A$ בגודל $2 \times x$, כך שכדי לבנות את 
			הקוד הזדוני בזמן ריצה, צריך לבקש מהספרייה החיצונית את התווים  
			במיקום 
			$A[i, 0]$ 
			עד ל- 
			$A[i, 1]$, 
			ולשרשר את הכל ביחד. 
			בזמן ריצה אנו דורשים שנקבל את הסיפרייה בגרסא הספציפית שאנו צריכים, ואז בונים את הקוד ומריצים אותו. 
			ובצורה כזאת, אנו בונים את הקוד ע"י טקסט שאנו לא שומרים אותו. 
			\subsubsection{שלב עשירי} 
			\goal 
			החבאת הקוד הזדוני, ללא ידיעה שהוא קיים )סטגנוגרפיה(. \\
			\action 
			בחרנו להחביא את הקוד הזדוני בתוך תמונה. 
			רשמנו את הערך ה- 
			\L{ASCII} 
			של תווי הקוד הזדוני בתור הערך של הפיקסלים באחד הערוצים. 
			בזמן ריצה, נקרא את התמונה, ונשרשר את התווים של הפיקסלים )כל פיקסל מסמן ערך של תו( . 
			בחרנו איפה לרשום את הקוד בתמונה, בכך שקירוב הרבועיים בין ערך תווי הקוד לערך הפיקסלים המקוריים הוא מינמלי. 
			שמרנו בקוד את האינדקס של התו הראשון בתמונה. 

			\L{\begin{figure}[h]
					\centering
					\R{\caption{דוגמא לקוד שמוחבא בתמונה )בתוך העיגול הכחול, הקוד מוחבא(}}
					\includegraphics[scale=0.4]{after}
					\includegraphics[scale=0.2]{before}
			\end{figure}} 
			\subsection*{\L{Hide the Code in Classes}}
			\subsubsection{שלב אחד-עשר}
			\goal 
			חסרון שלישי. רצינו להקשות על ביצוע 
			\L{Reverse Engineering}. 
			לשלבים שעד כה הצגנו, ביצוע 
			\L{Reverse Engineering} 
			אינה משימה קשה. לעומת זאת, לעשות 
			\L{Reverse Engineering} 
			לקוד 
			\L{C++} 
			קלאסי הופכת להיות משימה מאוד קשה. 
			בין כי יש 
			\L{Destructor} 
			וירושות ובין כי יש אופטימיזציות של המהדר. 
			אחת הבעיות העיקריות היא בעת יצירת ירושות ויצירת פונקציות וירטואליות. כאשר נוצר 
			\L{Virtual Tables} 
			קשה מאוד בכל רגע נתון לדעת לאיזה פונקציה עומדים לקרוא. \\
			\action 
			החבאנו את יצירת הקוד הזדוני בתוך המחלקות והפונקציות 
			הוירטואליות שלהן. המחלקות שיצרנו יורשות אחת מהשניה, 
			כדי שתיווצר טבלה וירטאלית כך שיהיה קשה לדעת לאיזה פונקציה 
			קוראים בכל פעם. 
			בתכנון מקדים אנו מגרילים את היררכיית המחלקות, ומייצרים את המחלקות בצורה אוטומטית. 
			\subsection*{\L{Classes, Lookup Table, Encryption}}
			\subsubsection{שלב שניים-עשר} 
			\goal 
			רצינו לשלב בין שלבים שעשינו. 
			\action 
			בהתחלה שילבנו בין שמירה של הקוד בתמונה לבין שיטות ההצפנה. 
			הצפנו את הקוד, ולאחר מכן שמרנו אותו בתמונה. 
			הבעיה שנוצרה היא שהתווים שאנו צריכים לשמור הם אקראיים, 
			לכן התמונה נראת לא טבעית באזור ההחבאה של הקוד. לכן עזבנו את הרעיון.  
			בנוסף, ניסינו לשלב בין 
			\L{Lookup Table} 
			לבין ההחבאה בתמונה, אבל באינדקסים ששמרנו ב- 
			\L{Lookup Table} 
			היו גדולים מידי, ודרשנו יותר מבית אחד. 
			ושוב, התמונה הייתה נראת לא טבעית. 
			\L{\begin{figure}[h]
					\centering
					\R{\caption{
	השוואה בין החבאת הקוד המוצפן ללא מוצפן. )משמאל, החבאת הקוד המוצפן(}}
					\includegraphics[scale=0.4]{after_enc}
					\includegraphics[scale=0.4]{after}
			\end{figure}} 
			\subsubsection{שלב שלושה-עשר} 
			\action  
			שילבנו בין יצירת הקוד הזדוני בעזרת ספריית אינטרנט, לבין 
			החבאת הקוד בתוך מחלקות. 
			בתכנון מקדים בדקנו איך ניתן ליצור את הקוד הזדוני ע"י ספריית האינטרנט, ויצרנו את המחלקות כך שישמרו את הדרך שבה נבנה את הקוד הזדוני בזמן ריצה. 
			\subsection*{\L{Sandbox Defense}}
			\subsubsection{שלב ארבעה-עשר}
			\goal 
			בשלב זה התמקדנו בלגבור על כך שהדפדפנים עלולים להריץ את הקוד ב- 
			\L{Sandbox}. 
			כל המפענחים שהצגנו עד כה, מייצרים את הקוד הזדוני ומריצים אותו מיד. 
			לכן, אם דפדפן יריץ את המפענח ב- 
			\L{Sandbox} 
			הוא יצליח לזהות שהוא מריץ קוד זדוני.  \\
			\action 
			התלנו את הרצת הקוד בקלט המשתמש. אנו מחכים ל- 
			\L{Event} 
			שקורה כאשר קורדינטות העכבר הם ברדיוס מסויים מסביב ל- $x, y$ )המוגרלים באקראי(. 
			וידאנו שהם לא קיצוניים מידי במסך, כדי שזה יקרה מהר יותר, ושאכן הן בגבולות המסך. 
			ברגע, שהעכבר הגיע למיקום שציפינו לו, אנו מריצים את הקוד הזדוני. 
			\L{Sandboxes} 
			לא יוכלו לגרום להיווצרות הקוד הזדוני, כי בדר"כ אין להם עכבר, 
			וגם אם כן אז הם אינם מזיזים אותו. 
			\subsubsection{שלב חמישה-עשר}
			\goal 
			כדי להתגבר על השלב הקודם, 
			\L{Sandboxes} 
			מנסים להריץ את כל חלקי הקוד שנראים בלתי תלויים, ולכן עלולים לזהות את הרצת הקוד הזדוני. \\
			\action 
			שמרנו את הקוד בתור מחרוזת, והחסרנו ממנו תו קריטי )לדוגמא סוגר(, כך שהקוד לא יהיה תקין בלעדיו.  
			את התו הזה ננחש שהוא קורדינטת ה- $x$ של העכבר )עם מינוס 
			\L{offset} 
			אקראי, וברדיוס קטן(. 
			כעת תמיד ננסה להריץ את הקוד שאנו מייצרים. 
			אם העכבר לא בקורדיטה הנכונה, הקוד שלנו לא יצליח להתקמפל ויקרוס. 
			בצורה כזאת, רק כאשר המשתמש יזיז את העכבר לאזור הנכון, נקבל את התו הנכון והקוד הזדוני יהיה תקין וירוץ. 
			
			\L{\begin{figure}[h]
				\centering
				\R{\caption{
						המסך מחולק ל-7 חלקים. רק כאשר העכבר יהיה בחלק הנכון, הקוד יהיה תקין ויצליח להתקמפל, מכיוון והתו היחיד שיכול לגרום לקוד להתקמפל הוא '$)$' )בצהוב ניתן לראות שחסר התו( }}
				\includegraphics[scale=0.5]{get_client_mouse}
			\end{figure}}
			
			\subsection*{\L{Final Stage}}
			\subsubsection{שלב שישה-עשר}		
			\goal 
			רצינו לנצל את תכונות כל השלבים, ולייצר מפענח שנהנה מהיתרונות של כולם. \\
			\action 
			שילבנו בין שלבים $13$ ו- $15$. 
			לקחנו את הקוד שמיוצר ע"י שלב $13$, והחסרנו ממנו )כמו בשלב $15$( תו קריטי. 
			ובזמן ריצה מנחשים את התו על פי קורדינטת העכבר. 
			וכאשר המשתמש יזיז את העכבר לאזור הנכון, נקבל את התו הנכון והקוד הזדוני יהיה תקין וירוץ. 
	\section{תוצרים} 
	התוצר של הפרויקט הינו שיטה להחבאת כל קוד 
	\L{Javascript} 
	ממשתמש. \\ 
	אנו עושים בזאת בעזרת מפענחים. 
	המפענחים מקומפלים ל 
	\L{Web Assembly} 
	ויכול להריץ כל קוד 
	\L{Javascript} 
	שנותנים להם. 
	כדי לבדוק שהקוד באמת מוחבא וקשה לזיהוי, לקחנו וירוסים, והחבאנו אותם בעזרת המפענחים שלנו. 
	בדקנו בעזרת אתרים שונים, האם הם מזהים שאנו מריצים וירוס, ואף 
	\L{Anti Virus} 
	לא הצליח לזהות זאת. 
	
	\section{עבודה עתידית}
	במשך כמעט כל הפרויקט המטרה שלנו הייתה דרך להחבאת קוד זדוני. 
	ובמיוחד בשלבי הפרויקט המאוחרים, זאת מכיוון שאנו לא מתכוונים להריץ את הקוד מיד כאשר האתר עולה, אלא תזמנו את ההרצה באופן מתוחכם יותר. 
	לקראת סופו, הבנו שאפשר לנצל יותר מזה. 
	אתרים רבים משתמשים בשיטות שונות, בינהן בעזרת 
	\L{Obfuscator}, 
	כדי להחביא את קוד ה- 
	\L{Javascript} 
	שלהם נגד גניבות של חברות אחרות ומשתמשים שונים. 
	אנו נרצה שאתרים יוכלו להחביא את קוד ה 
	\L{Javascript} 
	שלהם. \\
	עבודה עתידית: היינו רוצים למצוא שיטות יעילות יותר ליצירת הקוד הזדוני, שעדיין לא יהיו ניתנות לזיהוי. \\
	בנוסף, אם נרצה להחביא את הקוד בצורה טובה יותר נצטרך להתמודד עם עוד בעיה. 
	הבעיה שיש אצלנו היא שאנו מייצרים את כל הקוד שאנו רוצים להריץ, ולאחר מכן מריצים אותו בפעם אחת. 
	נוצר מצב שיש לנו בזכרון את הקוד המלא, לכן נרצה לייצר את הקוד בחלקים והרצתם בנפרד. כך יהיה קשה יותר להרכיב אותו, אפילו אם יודעים איך הקוד הוחבא. 
	\section{שימוש משתמש בפרויקט}
	בפרויקט שלנו ניתן להריץ כל שלב בנפרד. 
	נסביר איך להתקין את סביבת העבודה, ואיך ניתן להריץ שלב. 
	\subsection{התקנת סביבת העבודה}
	הפרויקט מתואם ל- 
	\L{Windows}, 
	 
	
	\begin{enumerate}
		\item 
		תחילה, נדרש להוריד את הקוד שלנו. \\
		ניתן לבצע זאת ע"י 	
		\L{\$ git clone https://github.com/aradzu10/WebAssDecoders.git} \\
		או ע"י הורדה של ה- 
		\L{repository}: 
		\L{https://github.com/aradzu10/WebAssDecoders}. 
		\item 
		לאחר מכן, צריך להוריד את סביבת ה 
		\L{Web Assembly}. 
		ניתן להסתכל במדריך \\
		\L{https://emscripten.org/docs/getting\_started/downloads.html}. \\
		יש לשים את התיקייה  
		\L{emsdk-master} 
		יחד באותו 
		\L{repository}
		עם הפרויקט שלנו. 
		\item 
		בנוסף, בפרויקט שלנו השתמשנו ב
		\L{Python 3}. \\
		ניתן להוריד מכאן 
		\L{https://www.python.org/downloads/}.
		\item 
		אנו עבדנו ב-
		\L{IDE} 
		של 
		\L{Visual Studio Code}. 
		אנו ממליצים להוריד אותו, כדי לאפשר שימוש בכל הסקריפטים שכתבנו. 
		ניתן לעבוד גם בלעדיו. 		
	\end{enumerate} 
	
	\subsection{הרצת המפענחים}
	הפרויקט מחולק לתקיות. כל תקייה מכילה את כל הנדרש כדי להריץ את המפענח של אותו השלב. 
	\begin{enumerate}
		\item 
		בתקייה ישנו הקובץ 
		\L{code/code.txt}. 
		בקובץ זה אנו שומרים את הקוד שאנו רוצים להחביא. 
		\item 
		לאחר שבחרנו איזה קוד נרצה להחביא, צריך להריץ את התכנון המקדים, 
		את הקובץ 
		\L{src/preprocessing.py} 
		)בעזרת 
		\L{Python 3}(. 
		ה- 
		\L{script} 
		ייצר קובץ 
		\L{src/main.cpp} 
		ואת כל שאר הקבצים הנדרשים לשלב הנ"ל. 
		\item 
		לאחר מכן, נשאר לקמפל את קבצי השלב. \\
		במידה ולא עובדים עם 
		\L{Visual Studio Code}, 
		נדרש להריץ את הקובץ 
		\L{build/build\_and\_run.bat}. 
		ה- 
		\L{script} 
		מקבל שני ארגומנטים. הראשון הוא התקייה של קבצי השלב, השני הוא כתובת מלאה לקובץ ה 
		\L{Javascript} 
		שרוצים לקבל )קובץ ה-
		\L{output}(. 
		התקייה היא התקייה שקובץ ה- 
		\L{main} 
		נמצא בה. 
		אנו מניחים שהקובץ ה- 
		\L{output} 
		הוא 
		\L{build/main.js}. \\
		במידה וכן עובדים עם 
		\L{Visual Studio Code}. 
		נדרש לפתוח את קובץ ה- 
		\L{main}, 
		ובסרגל הכלים לבחור 
		\L{Terminal --$>$ Run Task... --$>$ Wasm build}. 
		\item 
		ה- 
		\L{Task} 
		או קובץ ה- 
		\L{bat}
		לא נסגר, מכיוון שהוא מריץ שרת, שצריך לרוץ כל עוד רוצים לגשת לאתר. 
		הכנו עמוד בסיסי המריץ את קוד ה- 
		\L{Web Assembly}. 
		ניתן לגשת עליו דרך 
		\L{localhost:8080/phaseX.html} )\L{X} זה מספר השלב שמריצים(. 
	\end{enumerate}
	
	\subsection{כיצד להרחיב/לשנות את הפרויקט} 
	
	הפרויקט נכתב בשלוש שפות. נציין מה נכתב בכל שפה, ובאותן שפות צריך להשתמש במידה ורוצים להרחיב/לשנות את אותו החלק. \\ 
	\textbf{\L{C $\backslash$ C++}.} 
	כתבנו את המפענחים, אשר מקמפלים אותם ל 
	\L{Web Assembly}.\\ 
	\textbf{\L{Javascript}.} 
	בשפה זו נכתב הקוד שאנו רוצים להחביא. \\ 
	\textbf{\L{Python 3}.} 
	לכל שלב נדרש הרצה של סקריפט תכנון מקדים. את הסקריפטים הללו כתבנו ב 
	\L{Python}. 

\end{document}